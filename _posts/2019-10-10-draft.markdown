---
layout: post
title:  "Elegant roles validation"
date:   2019-09-03 21:00:00
tags: oop
comments: true
shareable: true
author: maviteixeira
preview: When working with applications eventually we need to create a mechanism to restrict access to part of the system or even some funcionality. It's pretty common and I did too many times before but I never thougth about doing in a elegant way.


image: https://maviteixeira.com/images/prank_callers.png
--- 

When working with applications eventually we need to create a mechanism to restrict access to part of the system or even some specific funcionality. It's a pretty common issue and I did many times before but I never thougth about doing in a elegant way.

<figure class="articleimg">
    <img src="{{page.image}}" alt="Prank callers">
    <figcaption>
    Regular Show - Prank callers, by J.G. Quintel
    </figcaption>
</figure>

Recently I came across this problem in one of my pet projects, I need to restrict access to specific features based on the owner of the file. Let me give you an example:

In my scenario I can create virtual rooms and just the owner of the room is allowed to rename or close it on the other side common users can just join the room anytime.

{% highlight java %}
interface Room {

   fun rename(name: String)
   
   fun close()

   fun join()

}
{% endhighlight %}

The interface above translate the business behavior, given a specific room, you can rename, join or close it, depending of your authorization level you might succeed or not.

In the code below we receive a authenticated user via DI along with the connection and the room identifier (id), each method that require owner priviliges do a check before executing the task and throws an exception if the role is not compatible with the feature. 

{% highlight java %}
class PersistedRoom(
    private val connection: Connection,
    private val user: User,
    private val id: String
) : Room {

    override fun rename(name: String) {
        if(isOwner(user)){
            //Rename the room
        }
        throw RuntimeException("You are not the owner")
    }

    override fun join() {
        //Join the room
    }

    override fun close() {
        if(isOwner(user)){
            //Close the room
        }
        throw RuntimeException("You are not the owner")
    }

    private fun isOwner(user: User):Boolean {
        //Check if its the owner
    }

}
{% endhighlight %}

However the code that check the role is being repeated across multiple methods, possibly in the future we will need to add more roles increasing the complexity of the class. Let's say new we have a moderator role and its is allowed to rename but not close the room, just one less feature comparing to the owner. This will decrease cohesion of the class because now we need to handle all the room specific features and more roles at the same time.

My first step to work on this problem was to change the implementation of `PersistedRoom` this class should focus on the features that a common user will use, in our case it's just the join method, doing that will provide simpler code and a more cohesive class since we removed all the validation about roles.

{% highlight java %}
class PersistedRoom(
    private val connection: Connection,
    private val user: User,
    private val id: String
) : Room {

    override fun rename(name: String) {
        throw RuntimeException("You are not the owner")
    }

    override fun join() {
        //Join the room
    }

    override fun close() {
        throw RuntimeException("You are not the owner")
    }

}
{% endhighlight %}

Great, now we can use the same approach and handle specific owner features in a new implementation of Room called `OwnerPersistedRoom` just like the previous class it will focus on specific features of the room owner like rename and close, since we removed the role checking code eveything became more cohesive as well.

{% highlight java %}
class OwnerPersistedRoom(
    private val origin: Room,
    private val connection: Connection,
    private val id: String
) : Room {

    override fun rename(name: String) {
        //Rename the room
    }

    override fun join() {
        throw RuntimeException("You are the owner of the room")
    }

    override fun close() {
        //Close the room
    }

}
{% endhighlight %}

One thing to notice is that owner implementation is also a decorator so we need to create a instance of PersistedRoom anyway, I did this because I believe in the future features is very likely to have the same implementaiton being a owner or a common users and I don't want duplicated code inseide the classes and also seems more accurate semantically speaking.

Now to make sure we always create the right room for the job we need to modify our seach class adding the role verification on it.

{% highlight java %}
class PersistedRooms(
    private val connection: Connection,
    private val user: User
) : Rooms {
    override fun room(id: String): Room {
        //Search for a specific room

        val room = PersistedRoom(
            connection,
            user,
            id
        )
        if (user.id() == rows[0].getAs("owner")) {
            return AdminPersistedRoom(
                room,
                connection,
                id
            )
        }
        return room
    }
{% endhighlight %}

In the code above I implemented the roles validation checking if the user is the owner of the room, but we separated the room specific implementation details from the role verification and that's great. For me it make sense to put the room role check in the search providing a clean implementation to the caller, if we ever need to add a new role we just need to create a new implementation and handle the validation in the search class.

This is just an ideia to keep code separated and more cohesive, so the future modifications or extensions could be done easier. Right now it's respecting OOP principles and seems like a really reasonable approach in the long run. Let me know your thouthgs and if you have any ideias or questions.